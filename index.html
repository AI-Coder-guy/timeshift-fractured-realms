<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TimeShift: Fractured Realms — Neon</title>
<style>
  html,body{height:100%;margin:0;background:#050612;color:#e6f0ff;font-family:Inter,monospace;}
  canvas{display:block;margin:8px auto 0 auto;background:#040419;border-radius:6px;}
  #ui{width:880px;margin:12px auto;display:flex;justify-content:space-between;align-items:center;gap:8px}
  .meter{width:280px;height:14px;background:#0b0f17;border-radius:7px;overflow:hidden;border:1px solid #172034}
  .meter>i{display:block;height:100%;background:linear-gradient(90deg,#ff6b6b,#ffd86b);width:0%;}
  .label{font-size:13px;color:#cbdcff}
  button{background:#0f1724;color:#cfe0ff;border:1px solid #253047;padding:6px 10px;border-radius:6px;cursor:pointer}
  #hint{width:880px;margin:8px auto;color:#9fb3ff;font-size:13px;text-align:center}
  a { color: #88d7ff }
</style>
</head>
<body>
  <div id="ui">
    <div class="label">Mode: <strong id="modeLabel">FUTURE (recording)</strong></div>
    <div class="label">Cycle: <strong id="timerLabel">20.0s</strong></div>
    <div class="meter" title="Paradox meter"><i id="paradoxFill"></i></div>
    <div>
      <button id="toggleBtn">Toggle Mode (Space)</button>
      <button id="retryBtn">Retry Level (R)</button>
    </div>
  </div>
  <div id="hint">
    Controls: ← / → to move, Z or ↑ to jump, Space to toggle mode, R to retry level. Neon synthwave visuals & glitch on fracture.
  </div>
  <canvas id="game" width="880" height="520" tabindex="0"></canvas>

<script>
(() => {
  // ======= BASIC SETUP =======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // UI
  const modeLabel = document.getElementById('modeLabel');
  const timerLabel = document.getElementById('timerLabel');
  const paradoxFill = document.querySelector('.meter > i');
  const toggleBtn = document.getElementById('toggleBtn');
  const retryBtn = document.getElementById('retryBtn');

  // game config
  const GRAV = 0.9;
  const CYCLE_SECONDS = 20;
  const SPAWN_INPUT_IGNORE_MS = 160;
  let lastResetTime = performance.now();

  // runtime
  let mode = 'FUTURE'; // FUTURE = recording, PAST = play while echoes replay
  let cycleTimer = CYCLE_SECONDS;
  let glitchFrames = 0;
  let bgOffset = 0;

  // input
  const keys = {};
  canvas.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; if (e.code === 'Space') { e.preventDefault(); toggleMode(); } if (e.key.toLowerCase()==='r') resetLevel(); });
  canvas.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
  // allow click focus
  canvas.addEventListener('click', () => canvas.focus());
  canvas.focus();

  toggleBtn.addEventListener('click', toggleMode);
  retryBtn.addEventListener('click', resetLevel);

  // particles
  const particles = [];
  function spawnParticles(x, y, color, count = 10) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x: x + (Math.random()-0.5) * 12,
        y: y + (Math.random()-0.5) * 12,
        vx: (Math.random()-0.5) * 3,
        vy: (Math.random()-1.5) * 3,
        life: 20 + Math.random()*40,
        color
      });
    }
  }
  function updateParticles() {
    for (let i = particles.length-1; i >= 0; i--) {
      const p = particles[i];
      p.vy += 0.06;
      p.x += p.vx; p.y += p.vy;
      p.life--;
      if (p.life <= 0) particles.splice(i,1);
    }
  }
  function drawParticles() {
    for (const p of particles) {
      ctx.globalAlpha = Math.max(0, p.life / 60);
      ctx.fillStyle = p.color;
      ctx.fillRect(Math.round(p.x), Math.round(p.y), 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  // actor factory
  function makeActor(x, y, color) { return { x, y, w:22, h:30, vx:0, vy:0, onGround:false, color, inputs:{}, trail:[] }; }
  let player = makeActor(64, 320, '#8fffcf');
  let echoes = []; // each: { frames:[], actor, playing, frameIndex, color }
  let currentRecording = [];

  // paradox
  let paradox = 0;
  const PARADOX_MAX = 120;

  // rect collision (solid)
  function rectsOverlap(a,b) {
    return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
  }

  // ======= LEVEL DATA =======
  // Each level: platforms[], door, lever, optional lever2, dynamic[]
  const levels = [
    // 1: lever-door
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:40,y:380,w:220,h:16},{x:320,y:320,w:140,h:16}],
      door: {x:460,y:268,w:44,h:48,closed:true},
      lever: {x:260,y:356,w:20,h:20,pressed:false},
      dynamic: []
    },
    // 2: pressure/bridge
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:40,y:380,w:220,h:16},{x:270,y:320,w:200,h:16}],
      door: {x:740,y:280,w:44,h:48,closed:true},
      lever: {x:300,y:300,w:18,h:18,pressed:false},
      dynamic: []
    },
    // 3: laser switch
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:40,y:380,w:220,h:16}],
      door: {x:720,y:280,w:44,h:48,closed:true},
      lever: {x:260,y:300,w:18,h:18,pressed:false},
      dynamic: [{type:'laser',x:340,y:320,w:360,h:6,active:true}]
    },
    // 4: moving platform
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:40,y:380,w:220,h:16},{x:720,y:360,w:120,h:16}],
      door: {x:760,y:300,w:44,h:44,closed:true},
      lever: {x:360,y:320,w:20,h:20,pressed:false},
      dynamic: [{type:'moving',x:360,y:320,w:120,h:16,startX:360,endX:620,dir:1,speed:1.6}]
    },
    // 5: multi-lever
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:180,y:340,w:120,h:16},{x:340,y:300,w:120,h:16},{x:520,y:340,w:120,h:16}],
      door: {x:660,y:300,w:44,h:44,closed:true},
      lever: {x:200,y:316,w:18,h:18,pressed:false},
      lever2: {x:360,y:276,w:18,h:18,pressed:false},
      dynamic: []
    },
    // 6: falling blocks
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:60,y:380,w:120,h:16}],
      door: {x:740,y:280,w:44,h:44,closed:true},
      lever: {x:380,y:260,w:18,h:18,pressed:false},
      dynamic: [{type:'falling',x:240,y:200,w:96,h:16,active:false,triggered:false}]
    },
    // 7: paradox choice (optional)
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:60,y:380,w:120,h:16},{x:320,y:320,w:120,h:16}],
      door: {x:720,y:280,w:44,h:44,closed:true},
      lever: {x:360,y:296,w:18,h:18,pressed:false},
      dynamic: []
    },
    // 8: timed bridge
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:60,y:380,w:120,h:16}],
      door: {x:650,y:300,w:44,h:44,closed:true},
      lever: {x:240,y:316,w:18,h:18,pressed:false},
      dynamic: [{type:'bridge',x:320,y:332,w:140,h:12,active:false,timer:0,duration:4.0}]
    },
    // 9: vertical lift
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:60,y:380,w:120,h:16}],
      door: {x:650,y:200,w:44,h:44,closed:true},
      lever: {x:360,y:240,w:18,h:18,pressed:false},
      dynamic: [{type:'lift',x:360,y:320,w:80,h:16,startY:320,endY:200,vy:0,active:false}]
    },
    // 10: final merge
    {
      platforms: [{x:0,y:H-24,w:W,h:24},{x:200,y:340,w:120,h:16},{x:420,y:300,w:120,h:16},{x:600,y:340,w:120,h:16}],
      door: {x:720,y:280,w:44,h:44,closed:true},
      lever: {x:220,y:316,w:18,h:18,pressed:false},
      lever2: {x:440,y:276,w:18,h:18,pressed:false},
      dynamic: [{type:'moving',x:480,y:340,w:120,h:16,startX:480,endX:640,dir:1,speed:1.8}]
    }
  ];

  // ======= LEVEL STATE =======
  let currentLevel = 0;
  let {platforms, door, lever, lever2, dynamic} = cloneLevel(currentLevel);

  function cloneLevel(i) {
    const lv = JSON.parse(JSON.stringify(levels[i]));
    lv.dynamic = (lv.dynamic||[]).map(o => Object.assign({}, o));
    return { platforms: lv.platforms, door: lv.door, lever: lv.lever, lever2: lv.lever2 || null, dynamic: lv.dynamic };
  }

  // init player safely
  function spawnPlayer() {
    player.x = 64; player.y = 320; player.vx = 0; player.vy = 0; player.onGround = false; player.trail = [];
    lastResetTime = performance.now();
  }
  spawnPlayer();

  // ======= PHYSICS & GAME LOGIC =======
  function stepActor(actor, input) {
    const accel = 0.95;
    if (input.left) actor.vx -= accel;
    if (input.right) actor.vx += accel;
    actor.vx *= 0.92;
    if (input.jump && actor.onGround) { actor.vy = -14; actor.onGround = false; }
    actor.vy += GRAV;
    actor.x += actor.vx;
    actor.y += actor.vy;

    actor.onGround = false;
    // solids = platforms + dynamic platforms (moving, lift, bridge, falling)
    const solids = platforms.concat(dynamic.filter(o => ['moving','lift','bridge','falling'].includes(o.type)));
    for (const s of solids) {
      if (rectsOverlap(actor, s)) {
        const prevBottom = actor.y - actor.vy + actor.h;
        if (actor.vy >= 0 && prevBottom <= s.y + 3) {
          // land on top
          actor.y = s.y - actor.h;
          actor.vy = 0;
          actor.onGround = true;
        } else {
          // side collision push
          if (actor.x < s.x) actor.x = s.x - actor.w - 0.1;
          else actor.x = s.x + s.w + 0.1;
          actor.vx = 0;
        }
      }
    }

    // door blocks when closed
    if (door && door.closed && rectsOverlap(actor, door)) {
      if (actor.x + actor.w/2 < door.x + door.w/2) actor.x = door.x - actor.w - 0.5;
      else actor.x = door.x + door.w + 0.5;
      actor.vx = 0;
    }

    // world bounds
    if (actor.x < 0) actor.x = 0, actor.vx = 0;
    if (actor.x + actor.w > W) actor.x = W - actor.w, actor.vx = 0;
    if (actor.y > H + 220) {
      actor.x = 64; actor.y = 320; actor.vx = 0; actor.vy = 0; actor.onGround = false;
    }
  }

  // safe input (ignore initial hold after respawn to prevent slide)
  function getSafeInput() {
    if (performance.now() - lastResetTime < SPAWN_INPUT_IGNORE_MS) return { left:false, right:false, jump:false };
    return { left: keys['arrowleft'] || keys['a'], right: keys['arrowright'] || keys['d'], jump: keys['z'] || keys['w'] || keys['arrowup'] };
  }

  function fracture() {
    if (currentRecording.length > 6) {
      const e = { frames: currentRecording.slice(), actor: makeActor(currentRecording[0].x, currentRecording[0].y, '#78b8ff'), playing:true, frameIndex:0, color:'#78b8ff' };
      echoes.push(e);
    }
    currentRecording = [];
    mode = 'PAST';
    cycleTimer = CYCLE_SECONDS;
    if (echoes.length > 6) echoes.shift();
    glitchFrames = 8;
    spawnParticles(player.x + player.w/2, player.y + player.h/2, '#9fffcf', 12);
  }

  function toggleMode() {
    if (mode === 'FUTURE') fracture();
    else {
      mode = 'FUTURE'; cycleTimer = CYCLE_SECONDS; spawnPlayer();
    }
  }

  function resetLevel() {
    // reset current level state (not progression)
    echoes = [];
    currentRecording = [];
    paradox = 0;
    if (door) door.closed = true;
    if (lever) lever.pressed = false;
    if (lever2) lever2.pressed = false;
    // deep-clone dynamic objects to reset their runtime state
    const cloned = cloneLevel(currentLevel).dynamic;
    dynamic.length = 0; cloned.forEach(x => dynamic.push(x));
    spawnPlayer();
    mode = 'FUTURE'; cycleTimer = CYCLE_SECONDS;
  }

  function nextLevel() {
    currentLevel++;
    if (currentLevel >= levels.length) {
      alert('All levels completed! Restarting.');
      currentLevel = 0;
    }
    const lv = cloneLevel(currentLevel);
    platforms = lv.platforms; door = lv.door; lever = lv.lever; lever2 = lv.lever2 || null; dynamic = lv.dynamic;
    resetLevel();
  }

  // ======= RENDER HELPERS =======
  function renderBackground() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#071026'); g.addColorStop(1,'#000010');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    // moving magenta stripes
    for (let i = 0; i < 12; i++) {
      const a = 0.02 + Math.sin((bgOffset/28)+i) * 0.02;
      ctx.fillStyle = `rgba(255,0,255,${a})`;
      ctx.fillRect(0, i*42 + (bgOffset%42), W, 1);
    }
    bgOffset += 0.7;
  }

  function drawNeonRect(x,y,w,h,fillCol,strokeCol) {
    ctx.save();
    ctx.shadowBlur = 14; ctx.shadowColor = strokeCol || fillCol;
    ctx.fillStyle = fillCol; roundRect(ctx,x,y,w,h,6,true,false);
    ctx.restore();
    ctx.strokeStyle = strokeCol || '#00ffff'; ctx.lineWidth = 2; ctx.strokeRect(x,y,w,h);
  }

  function drawActor(a, color, ghost=false) {
    if (ghost) ctx.globalAlpha = 0.6;
    ctx.save();
    ctx.shadowBlur = 16; ctx.shadowColor = color;
    ctx.fillStyle = color; roundRect(ctx, Math.round(a.x), Math.round(a.y), a.w, a.h, 6, true, false);
    ctx.restore();
    // eyes
    ctx.fillStyle = '#04040a';
    ctx.fillRect(a.x + 5, a.y + 8, 4, 4);
    ctx.fillRect(a.x + a.w - 9, a.y + 8, 4, 4);
    if (ghost) ctx.globalAlpha = 1;
  }

  function drawEchoTrail(e) {
    const frames = e.frames;
    for (let i = 0; i < frames.length; i += 6) {
      const f = frames[i];
      const alpha = 0.06 + (i/frames.length) * 0.6;
      ctx.fillStyle = `rgba(130,255,255,${alpha})`;
      ctx.fillRect(f.x + 4, f.y + 6, 12, 8);
    }
  }

  function roundRect(c,x,y,w,h,r=6,fill=true,stroke=true) {
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
    if (fill) c.fill();
    if (stroke) c.stroke();
  }

  // ======= MAIN LOOP =======
  let last = performance.now();
  function loop() {
    const now = performance.now();
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    // update dynamic objects (so collisions see updated positions)
    for (const o of dynamic) {
      if (o.type === 'moving') {
        if (lever && lever.pressed) o.x += (o.speed || 1.6) * (o.dir || 1);
        // small auto-oscillate fallback so it doesn't get stuck
        if (o.x < o.startX) { o.x = o.startX; o.dir = 1; }
        if (o.x > o.endX) { o.x = o.endX; o.dir = -1; }
      } else if (o.type === 'falling') {
        if (o.triggered) { o.y += 2; if (o.y > H - 24 - o.h) o.y = H - 24 - o.h; }
        else if (lever && lever.pressed && !o.triggered) { o.triggered = true; spawnParticles(o.x + o.w/2, o.y + o.h/2, '#ffd86b', 10); }
      } else if (o.type === 'bridge') {
        if (lever && lever.pressed && !o.active) { o.active = true; o.timer = o.duration || 4.0; spawnParticles(o.x + o.w/2, o.y + o.h/2, '#aaffaa', 10); }
        if (o.active) { o.timer -= dt; if (o.timer <= 0) { o.active = false; spawnParticles(o.x + o.w/2, o.y + o.h/2, '#ffb86b', 8); } }
      } else if (o.type === 'lift') {
        if (lever && lever.pressed) { o.y -= 1.4; if (o.y < o.endY) o.y = o.endY; }
        else { o.y += 1.2; if (o.y > o.startY) o.y = o.startY; }
      } else if (o.type === 'laser') {
        o.active = !lever.pressed;
        if (o.active && Math.random() < 0.04) spawnParticles(o.x + Math.random()*o.w, o.y + Math.random()*o.h, '#ff4444', 1);
      }
    }

    // inputs
    const input = (performance.now() - lastResetTime < SPAWN_INPUT_IGNORE_MS) ? {left:false,right:false,jump:false} : { left: keys['arrowleft']||keys['a'], right: keys['arrowright']||keys['d'], jump: keys['z']||keys['w']||keys['arrowup'] };

    // update player / record
    if (mode === 'FUTURE') {
      player.inputs = input;
      stepActor(player, input);
      // record
      currentRecording.push({ x: player.x, y: player.y, vx: player.vx, vy: player.vy, input: {...player.inputs} });
    } else {
      player.inputs = input;
      stepActor(player, input);
      // update echoes playback
      for (const e of echoes) {
        if (!e.playing) continue;
        if (e.frameIndex === undefined) e.frameIndex = 0;
        const f = e.frames[e.frameIndex] || e.frames[e.frames.length - 1];
        e.actor.x = f.x; e.actor.y = f.y; e.actor.vx = f.vx; e.actor.vy = f.vy;
        e.frameIndex++;
        if (e.frameIndex >= e.frames.length) e.playing = false;
      }
    }

    // lever detection by player and echoes
    if (lever) lever.pressed = false;
    if (lever2) lever2.pressed = false;
    if (lever && rectsOverlap(player, lever)) lever.pressed = true;
    if (lever2 && rectsOverlap(player, lever2)) lever2.pressed = true;
    for (const e of echoes) {
      if (!e.playing) continue;
      if (lever && rectsOverlap(e.actor, lever)) lever.pressed = true;
      if (lever2 && rectsOverlap(e.actor, lever2)) lever2.pressed = true;
    }

    // door logic (multi-lever if lever2 exists)
    if (lever2) door.closed = !(lever.pressed && lever2.pressed);
    else door.closed = !lever.pressed;

    // paradox check
    for (const e of echoes) {
      if (!e.playing) continue;
      if (rectsOverlap(player, e.actor)) { paradox += 2; spawnParticles(player.x + player.w/2, player.y + player.h/2, '#ff6bff', 3); }
    }
    paradox = Math.max(0, paradox - 0.9);
    if (paradox >= PARADOX_MAX) { spawnParticles(player.x + player.w/2, player.y + player.h/2, '#ff9966', 22); resetLevel(); }

    // timer, fracture
    cycleTimer -= dt;
    if (cycleTimer <= 0) fracture();

    // particles update
    updateParticles();

    // UI update
    modeLabel.textContent = mode === 'FUTURE' ? 'FUTURE (recording)' : 'PAST (playing)';
    timerLabel.textContent = `${Math.max(0, cycleTimer).toFixed(1)}s`;
    paradoxFill.style.width = `${Math.min(100, (paradox / PARADOX_MAX) * 100)}%`;

    // render
    render();

    requestAnimationFrame(loop);
  } // end loop

  // render function
  function render() {
    if (glitchFrames > 0) { ctx.save(); ctx.translate((Math.random()-0.5)*8, (Math.random()-0.5)*6); glitchFrames--; }
    renderBackground();

    // draw platforms
    for (const p of platforms) drawNeonRect(p.x, p.y, p.w, p.h, '#111827', '#00ffff');

    // draw dynamic objects
    for (const o of dynamic) {
      if (o.type === 'laser') {
        if (o.active) { ctx.fillStyle = 'rgba(255,80,80,0.95)'; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle='rgba(255,120,120,0.6)'; ctx.lineWidth=2; ctx.strokeRect(o.x-2,o.y-2,o.w+4,o.h+4); }
        else { ctx.fillStyle='rgba(255,80,80,0.12)'; ctx.fillRect(o.x,o.y,o.w,o.h); }
      } else {
        const active = (o.type === 'bridge') ? o.active : true;
        const fillC = active ? '#ffd86b' : '#4a3a16';
        drawNeonRect(o.x, o.y, o.w, o.h, fillC, '#ffe58a');
      }
    }

    // door/lever
    drawNeonRect(door.x, door.y, door.w, door.h, door.closed ? '#b84a5a' : '#4ab86a', door.closed ? '#ff88aa' : '#88ff99');
    if (lever) drawNeonRect(lever.x, lever.y, lever.w, lever.h, lever.pressed ? '#ffd86b' : '#aaaaaa', '#ffff66');
    if (lever2) drawNeonRect(lever2.x, lever2.y, lever2.w, lever2.h, lever2.pressed ? '#ffd86b' : '#aaaaaa', '#ffff66');

    // echoes (trails and ghost)
    for (const e of echoes) {
      if (!e.playing) continue;
      drawEchoTrail(e);
      drawActor(e.actor, e.color, true);
    }

    // player
    drawActor(player, player.color);

    // particles
    drawParticles();

    // locked overlay
    if (door.closed) {
      ctx.fillStyle = 'rgba(6,6,8,0.7)';
      ctx.fillRect(door.x, door.y, door.w, door.h);
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px monospace';
      ctx.fillText('LOCKED', door.x + 6, door.y + door.h/2 + 5);
    }

    // HUD
    ctx.fillStyle = '#d7e7ff';
    ctx.font = '12px monospace';
    ctx.fillText(`Paradox: ${Math.round(paradox)}/${PARADOX_MAX}`, 12, 18);

    if (glitchFrames > 0) ctx.restore();
  }

  function renderBackground() {
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#071026'); g.addColorStop(1,'#000010');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
    // magenta scanlines
    for (let i=0;i<12;i++){
      const a = 0.02 + Math.sin((bgOffset/28)+i)*0.02;
      ctx.fillStyle = `rgba(255,0,255,${a})`;
      ctx.fillRect(0, i*42 + (bgOffset%42), W, 1);
    }
    bgOffset += 0.7;
  }

  function drawNeonRect(x,y,w,h,fillCol,strokeCol) {
    ctx.save();
    ctx.shadowBlur = 14; ctx.shadowColor = strokeCol || fillCol;
    ctx.fillStyle = fillCol; roundRect(ctx,x,y,w,h,6,true,false);
    ctx.restore();
    ctx.strokeStyle = strokeCol || '#00ffff'; ctx.lineWidth = 2; ctx.strokeRect(x,y,w,h);
  }

  function drawActor(a,color,ghost=false) {
    if (ghost) ctx.globalAlpha = 0.6;
    ctx.save();
    ctx.shadowBlur = 16; ctx.shadowColor = color;
    ctx.fillStyle = color; roundRect(ctx, Math.round(a.x), Math.round(a.y), a.w, a.h, 6, true, false);
    ctx.restore();
    ctx.fillStyle = '#07070a';
    ctx.fillRect(a.x + 5, a.y + 8, 4, 4);
    ctx.fillRect(a.x + a.w - 9, a.y + 8, 4, 4);
    if (ghost) ctx.globalAlpha = 1;
  }

  function drawEchoTrail(e) {
    const frames = e.frames;
    for (let i = 0; i < frames.length; i += 6) {
      const f = frames[i];
      const alpha = 0.06 + (i / frames.length) * 0.6;
      ctx.fillStyle = `rgba(130,255,255,${alpha})`;
      ctx.fillRect(f.x + 4, f.y + 6, 12, 8);
    }
  }

  function roundRect(c,x,y,w,h,r=6,fill=true,stroke=true) {
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
    if (fill) c.fill();
    if (stroke) c.stroke();
  }

  // kick off loop
  requestAnimationFrame(loop);

  // expose nextLevel on double-click for quick testing (optional)
  // canvas.addEventListener('dblclick', () => nextLevel());

})();
</script>
</body>
</html>
