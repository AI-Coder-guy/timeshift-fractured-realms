<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TimeShift: Fractured Realms — Fixed</title>
<style>
  html,body{height:100%;margin:0;background:#060414;color:#fff;font-family:monospace;}
  canvas{display:block;margin:0 auto;background:#060414; image-rendering: pixelated;}
  #ui{width:880px;margin:12px auto;display:flex;justify-content:space-between;align-items:center;gap:8px}
  .meter{width:280px;height:14px;background:#111;border-radius:7px;overflow:hidden;border:1px solid #222}
  .meter>i{display:block;height:100%;background:linear-gradient(90deg,#ff6b6b,#ffd86b);width:0%;}
  .label{font-size:13px;color:#bfc7ff}
  button{background:#0f1724;color:#cfe0ff;border:1px solid #253047;padding:6px 10px;border-radius:6px;cursor:pointer}
  #hint{width:880px;margin:6px auto;color:#b1c0ff;font-size:13px}
</style>
</head>
<body>
  <div id="ui">
    <div class="label">Mode: <strong id="modeLabel">FUTURE (recording)</strong></div>
    <div class="label">Cycle: <strong id="timerLabel">20.0s</strong></div>
    <div class="meter" title="Paradox meter"><i id="paradoxFill"></i></div>
    <div>
      <button id="toggleBtn">Toggle Mode (Space)</button>
      <button id="retryBtn">Retry Level (R)</button>
    </div>
  </div>
  <div id="hint">Controls: ←/→ to move, Z to jump, Space to toggle mode, R to retry level. (Spawn input ignored briefly after restart.)</div>
  <canvas id="game" width="880" height="520"></canvas>

<script>
(() => {
  // ---- Config ----
  const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const GRAV = 0.9;
  const CYCLE_SECONDS = 20;
  const SPAWN_INPUT_IGNORE_MS = 150; // ignore inputs briefly after reset
  let lastResetTime = 0;

  // UI
  const modeLabel = document.getElementById('modeLabel');
  const timerLabel = document.getElementById('timerLabel');
  const paradoxFill = document.querySelector('.meter > i');
  const toggleBtn = document.getElementById('toggleBtn');
  const retryBtn = document.getElementById('retryBtn');

  // State
  let mode = 'FUTURE'; // FUTURE = recording, PAST = play while echoes replay
  let cycleTimer = CYCLE_SECONDS;
  let glitchFrames = 0;
  let bgOffset = 0;

  // Input
  const keys = {};
  document.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (e.code === 'Space') { e.preventDefault(); toggleMode(); }
    if (e.key.toLowerCase() === 'r') resetLevel();
  });
  document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  toggleBtn.addEventListener('click', toggleMode);
  retryBtn.addEventListener('click', resetLevel);

  // Particles
  const particles = [];
  function spawnParticles(x, y, color, count = 10) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x: x + (Math.random() - 0.5) * 10,
        y: y + (Math.random() - 0.5) * 10,
        vx: (Math.random() - 0.5) * 3,
        vy: (Math.random() - 1.5) * 3,
        life: 30 + Math.random() * 30,
        color
      });
    }
  }
  function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.vy += 0.08;
      p.x += p.vx; p.y += p.vy;
      p.life--;
      if (p.life <= 0) particles.splice(i, 1);
    }
  }
  function drawParticles() {
    for (const p of particles) {
      ctx.globalAlpha = Math.max(0, p.life / 50);
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  // Actors (player + echoes)
  function makeActor(x, y, color) {
    return { x, y, w: 22, h: 30, vx: 0, vy: 0, onGround: false, color, inputs: {}, trail: [] };
  }
  let player = makeActor(64, 320, '#9effc9');
  let echoes = []; // { frames: [...], actor, playing, frameIndex, color }
  let currentRecording = [];

  // Paradox
  let paradox = 0;
  const PARADOX_MAX = 120;

  // Collision helper — FIXED (no self-referential bug)
  function rectsOverlap(a, b) {
    return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
  }

  // Level definitions — all 10 levels included and interactive
  const levels = [
    // 1 — lever door simple (beatability ensured)
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 40, y: 380, w: 220, h: 16 }, { x: 320, y: 320, w: 140, h: 16 }],
      door: { x: 460, y: 268, w: 44, h: 48, closed: true },
      lever: { x: 260, y: 356, w: 20, h: 20, pressed: false },
      dynamic: []
    },
    // 2 — pressure plate / bridge
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 40, y: 380, w: 220, h: 16 }, { x: 270, y: 320, w: 200, h: 16 }],
      door: { x: 740, y: 320 - 40, w: 40, h: 40, closed: true },
      lever: { x: 300, y: 300, w: 18, h: 18, pressed: false }, // pressure plate behaves like lever for prototype
      dynamic: []
    },
    // 3 — laser switch (laser blocks path)
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 40, y: 380, w: 220, h: 16 }],
      door: { x: 720, y: 320 - 40, w: 40, h: 40, closed: true },
      lever: { x: 260, y: 300, w: 18, h: 18, pressed: false },
      dynamic: [{ type: 'laser', x: 340, y: 320, w: 360, h: 6, active: true }]
    },
    // 4 — moving platform
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 40, y: 380, w: 220, h: 16 }, { x: 720, y: 360, w: 120, h: 16 }],
      door: { x: 760, y: 300, w: 44, h: 44, closed: true },
      lever: { x: 360, y: 320, w: 20, h: 20, pressed: false },
      dynamic: [{ type: 'moving', x: 360, y: 320, w: 120, h: 16, startX: 360, endX: 620, dir: 1, speed: 1.6 }]
    },
    // 5 — multi-lever
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 180, y: 340, w: 120, h: 16 }, { x: 340, y: 300, w: 120, h: 16 }, { x: 520, y: 340, w: 120, h: 16 }],
      door: { x: 660, y: 300, w: 44, h: 44, closed: true },
      lever: { x: 200, y: 316, w: 18, h: 18, pressed: false },
      lever2: { x: 360, y: 276, w: 18, h: 18, pressed: false },
      dynamic: []
    },
    // 6 — falling blocks
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 60, y: 380, w: 120, h: 16 }],
      door: { x: 740, y: 320 - 40, w: 40, h: 40, closed: true },
      lever: { x: 380, y: 260, w: 18, h: 18, pressed: false },
      dynamic: [{ type: 'falling', x: 240, y: 200, w: 96, h: 16, active: false }]
    },
    // 7 — paradox choice (optional paradox shortcut)
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 60, y: 380, w: 120, h: 16 }, { x: 320, y: 320, w: 120, h: 16 }],
      door: { x: 720, y: 320 - 40, w: 40, h: 40, closed: true },
      lever: { x: 360, y: 296, w: 18, h: 18, pressed: false },
      dynamic: []
    },
    // 8 — timed bridge
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 60, y: 380, w: 120, h: 16 }],
      door: { x: 650, y: 300, w: 44, h: 44, closed: true },
      lever: { x: 240, y: 316, w: 18, h: 18, pressed: false },
      dynamic: [{ type: 'bridge', x: 320, y: 332, w: 140, h: 12, active: false, timer: 0, duration: 4.0 }]
    },
    // 9 — vertical shaft (lift)
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 60, y: 380, w: 120, h: 16 }],
      door: { x: 650, y: 200, w: 44, h: 44, closed: true },
      lever: { x: 360, y: 240, w: 18, h: 18, pressed: false },
      dynamic: [{ type: 'lift', x: 360, y: 320, w: 80, h: 16, startY: 320, endY: 200, vy: 0, active: false }]
    },
    //10 — final merged challenge (moving platform + 2 levers)
    {
      platforms: [{ x: 0, y: H - 24, w: W, h: 24 }, { x: 200, y: 340, w: 120, h: 16 }, { x: 420, y: 300, w: 120, h: 16 }, { x: 600, y: 340, w: 120, h: 16 }],
      door: { x: 720, y: 280, w: 44, h: 44, closed: true },
      lever: { x: 220, y: 316, w: 18, h: 18, pressed: false },
      lever2: { x: 440, y: 276, w: 18, h: 18, pressed: false },
      dynamic: [{ type: 'moving', x: 480, y: 340, w: 120, h: 16, startX: 480, endX: 640, dir: 1, speed: 1.8 }]
    },
  ];

  // current level state
  let currentLevelIndex = 0;
  let { platforms, door, lever, lever2, dynamic } = deepCloneLevel(currentLevelIndex);

  // utility to clone level objects so we can mutate dynamic state safely
  function deepCloneLevel(levelIndex) {
    const lv = JSON.parse(JSON.stringify(levels[levelIndex]));
    // convert dynamic items to proper objects with functions if needed
    lv.dynamic = (lv.dynamic || []).map(o => Object.assign({}, o));
    return { platforms: lv.platforms, door: lv.door, lever: lv.lever, lever2: lv.lever2 || null, dynamic: lv.dynamic };
  }

  // Debug helper: reset velocities and states (fixes glide bug)
  function initPlayerAtStart() {
    player.x = 64; player.y = 320;
    player.vx = 0; player.vy = 0; player.onGround = false;
    player.trail = [];
    lastResetTime = performance.now();
  }

  initPlayerAtStart();

  // physics / actor step
  function stepActor(actor, input, dt = 1 / 60) {
    // ignore tiny time deltas at very start to avoid drift
    const accel = 0.95;
    if (input.left) actor.vx -= accel;
    if (input.right) actor.vx += accel;
    actor.vx *= 0.92;
    if (input.jump && actor.onGround) { actor.vy = -14; actor.onGround = false; }
    actor.vy += GRAV;
    actor.x += actor.vx;
    actor.y += actor.vy;

    // collision with static platforms first
    actor.onGround = false;
    const solids = platforms.concat(dynamic.filter(o => ['moving', 'lift', 'bridge', 'falling'].includes(o.type)));
    for (const p of solids) {
      if (rectsOverlap(actor, p)) {
        const prevBottom = actor.y - actor.vy + actor.h;
        // landed on top
        if (actor.vy >= 0 && prevBottom <= p.y + 2) {
          actor.y = p.y - actor.h;
          actor.vy = 0;
          actor.onGround = true;
        } else {
          // side collision — push out horizontally
          if (actor.x < p.x) actor.x = p.x - actor.w - 0.1;
          else actor.x = p.x + p.w + 0.1;
          actor.vx = 0;
        }
      }
    }

    // door blocking: if door closed and overlapping, push back
    if (door && door.closed && rectsOverlap(actor, door)) {
      // push back depending on which side actor is coming from
      if (actor.x + actor.w / 2 < door.x + door.w / 2) actor.x = door.x - actor.w - 0.5;
      else actor.x = door.x + door.w + 0.5;
      actor.vx = 0;
    }

    // world bounds/fall reset
    if (actor.x < 0) actor.x = 0, actor.vx = 0;
    if (actor.x + actor.w > W) actor.x = W - actor.w, actor.vx = 0;
    if (actor.y > H + 220) {
      // fall reset only that actor
      actor.x = 64; actor.y = 320; actor.vx = 0; actor.vy = 0; actor.onGround = false;
    }
  }

  // gameplay functions
  function fracture() {
    // record and spawn echo
    if (currentRecording.length > 6) {
      const e = {
        frames: currentRecording.slice(),
        color: '#7eaef0',
        actor: makeActor(currentRecording[0].x, currentRecording[0].y, '#7eaef0'),
        playing: true,
        frameIndex: 0
      };
      echoes.push(e);
    }
    currentRecording = [];
    mode = 'PAST';
    cycleTimer = CYCLE_SECONDS;
    if (echoes.length > 5) echoes.shift();
    glitchFrames = 8;
    spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#8fffcf', 14);
  }

  function toggleMode() {
    if (mode === 'FUTURE') {
      fracture();
    } else {
      mode = 'FUTURE';
      cycleTimer = CYCLE_SECONDS;
      // reset player to level start and clear velocities — prevents sliding glitch
      initPlayerAtStart();
    }
  }

  function resetLevel() {
    // reset everything for current level (not progression)
    echoes = [];
    currentRecording = [];
    paradox = 0;
    if (door) door.closed = true;
    if (lever) lever.pressed = false;
    if (lever2) lever2.pressed = false;
    // reinitialize dynamic objects to original level values to clear carry-over
    const d = deepCloneLevel(currentLevelIndex).dynamic;
    dynamic.length = 0;
    d.forEach(x => dynamic.push(x));
    initPlayerAtStart();
    mode = 'FUTURE';
    cycleTimer = CYCLE_SECONDS;
  }

  function nextLevel() {
    currentLevelIndex++;
    if (currentLevelIndex >= levels.length) {
      // finished all levels -> restart
      alert('All levels complete! Restarting...');
      currentLevelIndex = 0;
    }
    // load level
    const lv = deepCloneLevel(currentLevelIndex);
    platforms = lv.platforms;
    door = lv.door;
    lever = lv.lever;
    lever2 = lv.lever2 || null;
    dynamic.length = 0;
    lv.dynamic.forEach(o => dynamic.push(o));
    resetLevel();
  }

  // initial dynamic array from current clone
  let dynamic = (deepCloneLevel(currentLevelIndex).dynamic || []);

  // Input guard — ignore inputs very briefly after resets to avoid sliding due to held keys
  function getInputSafe() {
    const now = performance.now();
    if (now - lastResetTime < SPAWN_INPUT_IGNORE_MS) {
      return { left: false, right: false, jump: false };
    }
    return {
      left: keys['arrowleft'] || keys['a'],
      right: keys['arrowright'] || keys['d'],
      jump: keys['z'] || keys['w'] || keys['arrowup']
    };
  }

  // main loop
  let last = performance.now();
  function loop() {
    const now = performance.now();
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    // update dynamic objects first (so collision sees new positions)
    for (const o of dynamic) {
      if (o.type === 'moving') {
        // move left/right if lever pressed
        if (lever && lever.pressed) {
          o.x += (o.speed || 1.6) * (o.dir || 1);
        } else {
          // gentle auto-oscillate when not pressed, so it doesn't carry too far
          o.x += 0;
        }
        if (o.x < o.startX) o.x = o.startX, o.dir = 1;
        if (o.x > o.endX) o.x = o.endX, o.dir = -1;
      } else if (o.type === 'falling') {
        if (o.triggered) {
          o.y += 2; // fall speed
          if (o.y > H - 24 - o.h) o.y = H - 24 - o.h;
        } else if (lever && lever.pressed && !o.triggered) {
          // pressing lever triggers fall
          o.triggered = true;
          spawnParticles(o.x + o.w / 2, o.y + o.h / 2, '#ffd86b', 10);
        }
      } else if (o.type === 'bridge') {
        if (lever && lever.pressed && !o.active) {
          o.active = true; o.timer = o.duration || 4.0;
          spawnParticles(o.x + o.w / 2, o.y + o.h / 2, '#aaffaa', 12);
        }
        if (o.active) {
          o.timer -= dt;
          if (o.timer <= 0) o.active = false, spawnParticles(o.x + o.w / 2, o.y + o.h / 2, '#ffb86b', 8);
        }
      } else if (o.type === 'lift') {
        if (lever && lever.pressed) {
          // move lift up smoothly
          o.y -= 1.4;
          if (o.y < o.endY) o.y = o.endY;
        } else {
          // drop back
          o.y += 1.2;
          if (o.y > o.startY) o.y = o.startY;
        }
      } else if (o.type === 'laser') {
        // active depends on lever not pressed (or specific logic)
        o.active = !lever.pressed;
        // spawn some small sparks if active
        if (o.active && Math.random() < 0.04) spawnParticles(o.x + Math.random() * o.w, o.y + Math.random() * o.h, '#ff4444', 1);
      }
    }

    // input
    const input = getInputSafe();

    // step player and recording logic (future records)
    if (mode === 'FUTURE') {
      player.inputs = input;
      stepActor(player, input, dt);
      // record small frame (position, input)
      currentRecording.push({ x: player.x, y: player.y, vx: player.vx, vy: player.vy, input: { ...player.inputs } });
    } else {
      // PAST mode: player plays, echoes replay
      player.inputs = input;
      stepActor(player, input, dt);
      // progress echoes
      for (const e of echoes) {
        if (!e.playing) continue;
        if (e.frameIndex === undefined) e.frameIndex = 0;
        const frame = e.frames[e.frameIndex] || e.frames[e.frames.length - 1];
        e.actor.x = frame.x; e.actor.y = frame.y; e.actor.vx = frame.vx; e.actor.vy = frame.vy;
        e.frameIndex++;
        if (e.frameIndex >= e.frames.length) e.playing = false;
      }
    }

    // lever detection (player or any echo)
    if (lever) lever.pressed = false;
    if (lever2) lever2.pressed = false;
    if (lever && rectsOverlap(player, lever)) lever.pressed = true;
    if (lever2 && rectsOverlap(player, lever2)) lever2.pressed = true;
    for (const e of echoes) {
      if (!e.playing) continue;
      if (lever && rectsOverlap(e.actor, lever)) lever.pressed = true;
      if (lever2 && rectsOverlap(e.actor, lever2)) lever2.pressed = true;
    }

    // door logic: for multi-lever require both
    if (lever2) door.closed = !(lever.pressed && lever2.pressed);
    else door.closed = !lever.pressed;

    // paradox checks (collision with active echoes)
    for (const e of echoes) {
      if (!e.playing) continue;
      if (rectsOverlap(player, e.actor)) {
        paradox += 2; // accumulate
        spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#ff6bff', 3);
      }
    }
    paradox = Math.max(0, paradox - 0.8);

    if (paradox >= PARADOX_MAX) {
      // big paradox -> reset current level
      spawnParticles(player.x + player.w / 2, player.y + player.h / 2, '#ff9966', 24);
      resetLevel();
    }

    // timer and auto-fracture
    cycleTimer -= dt;
    if (cycleTimer <= 0) fracture();

    // clamp echoes trail (for performance)
    if (echoes.length > 6) echoes = echoes.slice(-6);

    // particles update
    updateParticles();

    // UI updates
    modeLabel.textContent = mode === 'FUTURE' ? 'FUTURE (recording)' : 'PAST (playing)';
    timerLabel.textContent = `${Math.max(0, cycleTimer).toFixed(1)}s`;
    paradoxFill.style.width = `${Math.min(100, (paradox / PARADOX_MAX) * 100)}%`;

    // render
    render();

    requestAnimationFrame(loop);
  } // end loop

  // rendering helpers
  function renderBackground() {
    // animated synthwave gradient with subtle stripes
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#071026'); grad.addColorStop(1, '#000012');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);

    // moving scanlines
    for (let i = 0; i < 12; i++) {
      const a = 0.02 + Math.sin((bgOffset / 30) + i) * 0.02;
      ctx.fillStyle = `rgba(255,0,255,${a})`;
      ctx.fillRect(0, i * 44 + (bgOffset % 44), W, 1);
    }
    bgOffset += 0.6;
  }

  function drawNeonRect(x, y, w, h, fillColor, strokeColor) {
    ctx.save();
    ctx.shadowBlur = 14;
    ctx.shadowColor = strokeColor || fillColor;
    ctx.fillStyle = fillColor;
    roundRect(ctx, x, y, w, h, 6, true, false);
    ctx.restore();
    // bright stroke
    ctx.strokeStyle = strokeColor || '#00ffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, w, h);
  }

  function drawActor(a, color, ghost = false) {
    if (ghost) ctx.globalAlpha = 0.6;
    ctx.save();
    ctx.shadowBlur = 16;
    ctx.shadowColor = color;
    ctx.fillStyle = color;
    roundRect(ctx, Math.round(a.x), Math.round(a.y), a.w, a.h, 6, true, false);
    ctx.restore();
    // eyes / detail
    ctx.fillStyle = '#0b0b0f';
    ctx.fillRect(a.x + 5, a.y + 8, 4, 4);
    ctx.fillRect(a.x + a.w - 9, a.y + 8, 4, 4);
    if (ghost) ctx.globalAlpha = 1;
  }

  function drawEchoTrail(echo) {
    const frames = echo.frames;
    // sample every N frames so it's performant
    for (let i = 0; i < frames.length; i += 6) {
      const f = frames[i];
      const alpha = 0.08 + (i / frames.length) * 0.5;
      ctx.fillStyle = `rgba(130,255,255,${alpha})`;
      ctx.fillRect(f.x + 4, f.y + 6, 12, 8);
    }
  }

  function render() {
    // glitch transform
    if (glitchFrames > 0) { ctx.save(); ctx.translate((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 6); glitchFrames--; }

    renderBackground();

    // draw static platforms
    for (const p of platforms) {
      drawNeonRect(p.x, p.y, p.w, p.h, '#111827', '#00ffff');
    }

    // draw dynamic objects
    for (const o of dynamic) {
      if (o.type === 'laser') {
        if (o.active) {
          ctx.fillStyle = 'rgba(255,60,60,0.9)';
          ctx.fillRect(o.x, o.y, o.w, o.h);
          // laser glow
          ctx.strokeStyle = 'rgba(255,80,80,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(o.x - 2, o.y - 2, o.w + 4, o.h + 4);
        } else {
          // inactive laser faint
          ctx.fillStyle = 'rgba(255,60,60,0.12)';
          ctx.fillRect(o.x, o.y, o.w, o.h);
        }
      } else {
        // moving, lift, bridge, falling are platform-like
        const active = (o.type === 'bridge') ? o.active : true;
        const color = active ? '#ffd86b' : '#4a3a16';
        drawNeonRect(o.x, o.y, o.w, o.h, color, '#ffe58a');
      }
    }

    // door & levers
    ctx.save();
    drawNeonRect(door.x, door.y, door.w, door.h, door.closed ? '#b84a5a' : '#4ab86a', door.closed ? '#ff88aa' : '#88ff99');
    ctx.restore();
    if (lever) drawNeonRect(lever.x, lever.y, lever.w, lever.h, lever.pressed ? '#ffd86b' : '#aaaaaa', '#ffff66');
    if (lever2) drawNeonRect(lever2.x, lever2.y, lever2.w, lever2.h, lever2.pressed ? '#ffd86b' : '#aaaaaa', '#ffff66');

    // draw echo trails and echoes behind player
    for (const e of echoes) {
      if (!e.playing) continue;
      // trail
      drawEchoTrail(e);
      // actor ghost
      drawActor(e.actor, '#78b8ff', true);
    }

    // player
    drawActor(player, player.color);

    // particles
    drawParticles();

    // door locked label
    if (door.closed) {
      ctx.fillStyle = 'rgba(5,5,5,0.7)';
      ctx.fillRect(door.x, door.y, door.w, door.h);
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.fillText('LOCKED', door.x + 2, door.y + door.h / 2 + 5);
    }

    // HUD
    ctx.fillStyle = '#cdd9ff';
    ctx.font = '12px monospace';
    ctx.fillText(`Paradox: ${Math.round(paradox)}/${PARADOX_MAX}`, 10, 18);

    if (glitchFrames > 0) ctx.restore();
  }

  // drawing helper
  function roundRect(ctx, x, y, w, h, r = 6, fill = true, stroke = true) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // start loop
  requestAnimationFrame(loop);

  // expose next level on click for testing (optional)
  // canvas.addEventListener('dblclick', () => nextLevel());

  // ensure initial focus for keyboard
  canvas.tabIndex = 1000;
  canvas.focus();

})();
</script>
</body>
</html>
