<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TimeShift: Fractured Realms — Fixed Prototype</title>
<style>
html,body{margin:0;padding:0;height:100%;background:#0b0710;color:#fff;font-family:monospace;}
canvas{display:block;margin:0 auto;background:linear-gradient(#071026,#000);}
#ui{width:800px;margin:12px auto;display:flex;justify-content:space-between;align-items:center;}
.meter{width:220px;height:14px;background:#222;border-radius:7px;overflow:hidden;}
.meter>i{display:block;height:100%;background:linear-gradient(90deg,#ff6b6b,#ffb86b);width:0%;}
.label{font-size:13px;color:#bfc7ff;}
button{background:#111827;color:#bfc7ff;border:1px solid #2b2f44;padding:6px 10px;border-radius:6px;cursor:pointer;}
button:active{transform:translateY(1px)}
#hint{width:800px;margin:4px auto;color:#aab6ff;font-size:13px}
</style>
</head>
<body>
<div id="ui">
  <div class="label">Mode: <strong id="modeLabel">FUTURE (recording)</strong></div>
  <div class="label">Cycle: <strong id="timerLabel">20.0s</strong></div>
  <div class="meter" title="Paradox meter"><i id="paradoxFill"></i></div>
  <div><button id="toggleBtn">Toggle Mode (Space)</button></div>
</div>
<div id="hint">Controls: ←/→ to move, Z to jump, Space to toggle mode. Solve puzzles using echoes.</div>
<canvas id="game" width="800" height="480"></canvas>
<script>
(() => {
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const gravity = 0.9, dt=1/60, CYCLE_SECONDS=20;
let cycleTimer = CYCLE_SECONDS, mode='FUTURE';
const modeLabel = document.getElementById('modeLabel');
const timerLabel = document.getElementById('timerLabel');
const paradoxFill = document.getElementById('paradoxFill');
const toggleBtn = document.getElementById('toggleBtn');
const keys = {};
document.addEventListener('keydown',e=>{keys[e.key.toLowerCase()]=true;if(e.code==='Space'){e.preventDefault();toggleMode();}});
document.addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});
toggleBtn.addEventListener('click',toggleMode);

function makeActor(x,y,color){return{x:x,y:y,w:20,h:28,vx:0,vy:0,onGround:false,color:color||'#80e7ff',inputs:{}};}
let player = makeActor(60,320,'#a0ff9b');
let echoes=[];
let currentRecording=[];
let paradox=0;
const PARADOX_MAX=100;

// Levels
const levels=[
  {
    platforms:[{x:0,y:H-20,w:W,h:20},{x:40,y:360,w:200,h:16},{x:300,y:300,w:140,h:16},{x:520,y:360,w:220,h:16},{x:180,y:400,w:80,h:10}],
    door:{x:360,y:260,w:40,h:40,closed:true},
    lever:{x:220,y:360,w:20,h:20,pressed:false},
    type:'lever-door'
  },
  {
    platforms:[{x:0,y:H-20,w:W,h:20},{x:40,y:360,w:200,h:16},{x:260,y:300,w:200,h:16},{x:520,y:360,w:220,h:16}],
    door:{x:720,y:320,w:40,h:40,closed:true},
    lever:{x:260,y:280,w:20,h:20,pressed:false},
    type:'pressure-plate'
  },
  {
    platforms:[{x:0,y:H-20,w:W,h:20},{x:40,y:360,w:200,h:16},{x:260,y:300,w:200,h:16},{x:520,y:360,w:220,h:16}],
    door:{x:720,y:320,w:40,h:40,closed:true},
    lever:{x:260,y:280,w:20,h:20,pressed:false},
    type:'laser-switch'
  }
];
let currentLevel = 0;
let platforms=levels[currentLevel].platforms;
let door=levels[currentLevel].door;
let lever=levels[currentLevel].lever;

function rectsOverlap(a,b){return!(a.x+a.w<b.x||a.x>b.x+b.w||a.y+a.h<b.y||a.y>a.y+b.h);}
function stepActor(actor,input){
  const accel=0.9;if(input.left)actor.vx-=accel;if(input.right)actor.vx+=accel;actor.vx*=0.92;
  if(input.jump&&actor.onGround){actor.vy=-14;actor.onGround=false;}
  actor.vy+=gravity;actor.x+=actor.vx;actor.y+=actor.vy;
  actor.onGround=false;
  for(const p of platforms){
    if(rectsOverlap(actor,p)){
      const prevBottom=actor.y-actor.vy+actor.h;
      if(actor.vy>=0&&prevBottom<=p.y){actor.y=p.y-actor.h;actor.vy=0;actor.onGround=true;}
      else{if(actor.x<p.x)actor.x=p.x-actor.w-0.1;else actor.x=p.x+p.w+0.1;actor.vx=0;}}
  }
  if(actor.x<0)actor.x=0,actor.vx=0;if(actor.x+actor.w>W)actor.x=W-actor.w,actor.vx=0;
  if(actor.y>H+200){actor.x=60;actor.y=320;actor.vx=actor.vy=0;}
}
let last=performance.now();
function loop(now){
  const delta=Math.min(0.05,(now-last)/1000);last=now;
  cycleTimer-=delta;if(cycleTimer<=0){fracture();}
  if(mode==='FUTURE'){
    const input={left:keys['arrowleft']||keys['a'],right:keys['arrowright']||keys['d'],jump:keys['z']||keys['w']||keys['arrowup']||false};
    player.inputs=input;stepActor(player,input);currentRecording.push({x:player.x,y:player.y,vx:player.vx,vy:player.vy,input});
  }else{
    const input={left:keys['arrowleft']||keys['a'],right:keys['arrowright']||keys['d'],jump:keys['z']||keys['w']||keys['arrowup']||false};
    player.inputs=input;stepActor(player,input);
    for(const e of echoes){if(!e.playing)continue;e.frameIndex=e.frameIndex||0;
      const frame=e.frames[e.frameIndex]||e.frames[e.frames.length-1];e.actor.x=frame.x;e.actor.y=frame.y;e.actor.w=20;e.actor.h=28;e.frameIndex++;if(e.frameIndex>=e.frames.length)e.playing=false;
    }
  }
  lever.pressed=false;if(rectsOverlap(player,{x:lever.x,y:lever.y,w:lever.w,h:lever.h}))lever.pressed=true;
  for(const e of echoes){if(rectsOverlap(e.actor,{x:lever.x,y:lever.y,w:lever.w,h:lever.h}))lever.pressed=true;}
  door.closed=!lever.pressed;
  for(const e of echoes){if(!e.playing)continue;if(rectsOverlap(player,e.actor))paradox+=40*delta;}
  paradox=Math.max(0,paradox-8*delta);if(paradox>=PARADOX_MAX)resetLevel();
  modeLabel.textContent=mode==='FUTURE'?'FUTURE (recording)':'PAST (playing)';
  timerLabel.textContent=`${cycleTimer.toFixed(1)}s`;paradoxFill.style.width=Math.min(100,(paradox/PARADOX_MAX)*100+'%');
  render();requestAnimationFrame(loop);
}
function render(){
  ctx.clearRect(0,0,W,H);
  const g=ctx.createLinearGradient(0,0,0,H);g.addColorStop(0,'#0b0820');g.addColorStop(1,'#06040a');ctx.fillStyle=g;ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#1b2136';for(const p of platforms){roundRect(ctx,p.x,p.y,p.w,p.h,4,true,false);}
  ctx.fillStyle=door.closed?'#d46b6b':'#6bd46b';roundRect(ctx,door.x,door.y,door.w,door.h,3,true,false);
  ctx.fillStyle=lever.pressed?'#ffd86b':'#bbbbbb';roundRect(ctx,lever.x,lever.y,lever.w,lever.h,3,true,false);
  for(const e of echoes){if(!e.playing)continue;ctx.globalAlpha=0.65;drawActor(e.actor,e.color);ctx.globalAlpha=1.0;}
  drawActor(player,player.color);
  if(door.closed){ctx.fillStyle='rgba(10,10,10,0.6)';ctx.fillRect(door.x,door.y,door.w,door.h);ctx.fillStyle='#fff';ctx.font='13px monospace';ctx.fillText('LOCKED',door.x-2,door.y+door.h/2+5);}
  ctx.fillStyle='#c8d3ff';ctx.font='12px monospace';ctx.fillText(`Paradox: ${Math.round(paradox)}/${PARADOX_MAX}`,8,18);
}
function drawActor(a,color){ctx.fillStyle=color||'#8df';roundRect(ctx,Math.round(a.x),Math.round(a.y),a.w,a.h,4,true,false);ctx.fillStyle='#111';ctx.fillRect(a.x+5,a.y+8,3,3);ctx.fillRect(a.x+12,a.y+8,3,3);}
function roundRect(ctx,x,y,w,h,r,fill,stroke){if(r===undefined)r=6;ctx.beginPath();ctx.moveTo(x+r,y);ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);ctx.closePath();if(fill)ctx.fill();if(stroke)ctx.stroke();}
function fracture(){
  if(currentRecording.length>5){const e={frames:currentRecording.slice(),color:'#7eaef0',actor:makeActor(currentRecording[0].x,currentRecording[0].y,'#7eaef0'),playing:true,frameIndex:0};echoes.push(e);}
  currentRecording=[];mode='PAST';cycleTimer=CYCLE_SECONDS;if(echoes.length>4)echoes.shift();
}
function toggleMode(){
  if(mode==='FUTURE'){fracture();}else{mode='FUTURE';cycleTimer=CYCLE_SECONDS;player.x=60;player.y=320;player.vx=player.vy=0;}
}
function resetLevel(){
  echoes=[];currentRecording=[];paradox=0;door.closed=true;lever.pressed=false;player.x=60;player.y=320;player.vx=player.vy=0;mode='FUTURE';
}
function nextLevel(){
  currentLevel++;if(currentLevel>=levels.length){alert('All levels complete! Restarting.');currentLevel=0;}
  platforms=levels[currentLevel].platforms;door=levels[currentLevel].door;lever=levels[currentLevel].lever;resetLevel();
}
function checkWin(){if(!door.closed&&player.x>door.x+door.w&&player.y+player.h>door.y){alert(`Level ${currentLevel+1} complete!`);nextLevel();}}
setInterval(checkWin,200);requestAnimationFrame(loop);
})();
</script>
</body>
</html>
